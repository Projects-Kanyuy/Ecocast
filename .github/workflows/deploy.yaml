name: Deploy Static App

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger

env:
  AWS_REGION: us-east-1  # Change or override via workflow dispatch if needed
  TF_IN_AUTOMATION: true
  BUILD_DIR: dist
  BUILD_COMMAND: npm run build
  SKIP_BUILD: false

jobs:
  infra:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    outputs:
      bucket: ${{ steps.tf.outputs.bucket }}
      dist_id: ${{ steps.tf.outputs.dist_id }}
      domain: ${{ steps.tf.outputs.domain }}
    env:
      APP_NAME: ${{ github.repository_name }}  # Uses current repo name

    steps:
      - name: Checkout Infrastructure Repo
        uses: actions/checkout@v3
        with:
          repository: Projects-Kanyuy/infrastructure-npm
          path: infrastructure-npm
          token: ${{ secrets.REPO_PAT }}  # Must be set in repo secrets
          ref: main
          fetch-depth: 1

      - name: Set APP_NAME
        run: echo "APP_NAME=${{ env.APP_NAME }}" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}  # Must be set in secrets
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Cache Terraform plugins
      - name: Cache Terraform Plugins
        id: cache-terraform-plugins
        uses: actions/cache@v3
        with:
          path: ~/.terraform.d/plugin-cache
          key: terraform-plugins-${{ hashFiles('infrastructure-npm/terraform/frontend/*.tf', 'infrastructure-npm/terraform/frontend/*.tfvars') }}
          restore-keys: terraform-plugins-

      # Cache Terraform modules
      - name: Cache Terraform Modules
        id: cache-terraform-modules
        uses: actions/cache@v3
        with:
          path: infrastructure-npm/terraform/frontend/.terraform
          key: terraform-modules-${{ hashFiles('infrastructure-npm/terraform/frontend/*.tf', 'infrastructure-npm/terraform/tfvars/*.tfvars') }}
          restore-keys: terraform-

      # Cache Terraform lock file
      - name: Cache Terraform Lock File
        uses: actions/cache@v3
        continue-on-error: true
        with:
          path: infrastructure-npm/terraform/frontend/.terraform.lock.hcl
          key: terraform-lock-${{ hashFiles('infrastructure-npm/terraform/frontend/.terraform.lock.hcl') }}

      - name: Deploy Infrastructure
        working-directory: infrastructure-npm/terraform/frontend
        run: |
          echo "Running Terraform init..."
          terraform init -no-color -backend-config=../backends/${{ env.APP_NAME }}.tfbackend
          echo "Running Terraform plan..."
          terraform plan -no-color -var-file=../tfvars/${{ env.APP_NAME }}.tfvars
          echo "Running Terraform apply..."
          terraform apply -no-color -auto-approve -var-file=../tfvars/${{ env.APP_NAME }}.tfvars

      - name: Get Terraform Outputs
        id: tf
        working-directory: infrastructure-npm/terraform/frontend
        run: |
          echo "bucket=$(terraform output -raw bucket_name)" >> $GITHUB_OUTPUT
          echo "dist_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "domain=$(terraform output -raw cloudfront_domain)" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy Static App
    runs-on: ubuntu-latest
    needs: infra
    env:
      S3_BUCKET: ${{ needs.infra.outputs.bucket }}
      CLOUDFRONT_DISTRIBUTION_ID: ${{ needs.infra.outputs.dist_id }}
      CLOUDFRONT_DOMAIN: ${{ needs.infra.outputs.domain }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        if: ${{ env.SKIP_BUILD == 'false' }}
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Cache Node.js modules
        if: ${{ env.SKIP_BUILD == 'false' }}
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies and build
        if: ${{ env.SKIP_BUILD == 'false' }}
        run: |
          npm ci
          ${{ env.BUILD_COMMAND }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        id: deploy_s3
        run: |
          BUILD_DIR="${{ env.BUILD_DIR }}"
          echo "Deploying from directory: $BUILD_DIR"

          # Detect static file changes (exclude index.html)
          CHANGED=$(aws s3 sync "./$BUILD_DIR" "s3://$S3_BUCKET" \
            --delete \
            --region $AWS_REGION \
            --exclude "index.html" \
            --exact-timestamps \
            --cache-control "public, max-age=31536000, immutable" \
            --dryrun)

          if echo "$CHANGED" | grep -q "upload\|delete"; then
            aws s3 sync "./$BUILD_DIR" "s3://$S3_BUCKET" \
              --delete \
              --region $AWS_REGION \
              --exclude "index.html" \
              --exact-timestamps \
              --cache-control "public, max-age=31536000, immutable"
            echo "STATIC_FILES_CHANGED=true" >> $GITHUB_ENV
          else
            echo "No static assets changed."
            echo "STATIC_FILES_CHANGED=false" >> $GITHUB_ENV
          fi

          # Always update index.html with no-cache
          aws s3 cp "./$BUILD_DIR/index.html" "s3://$S3_BUCKET/index.html" \
            --region $AWS_REGION \
            --cache-control "no-cache, no-store, must-revalidate"
          echo "INDEX_HTML_CHANGED=true" >> $GITHUB_ENV

      - name: Invalidate CloudFront cache
        if: ${{ env.STATIC_FILES_CHANGED == 'true' || env.INDEX_HTML_CHANGED == 'true' }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_DISTRIBUTION_ID \
            --paths "/*" \
            --region $AWS_REGION

      - name: Deployment complete
        run: echo "App available at https://${{ env.CLOUDFRONT_DOMAIN }}"
